<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sonic Kaleidoscope</title>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            cursor: crosshair;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
        }
        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 0 10px #0f0;
            transition: opacity 0.5s;
            z-index: 10;
        }
        h1 { font-size: 3rem; margin-bottom: 10px; }
        p { font-size: 1.2rem; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>THE SONIC KALEIDOSCOPE</h1>
        <p>[ CLICK ANYWHERE TO ACTIVATE ]</p>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const overlay = document.getElementById("overlay");

        let width, height;
        let centerX, centerY;
        let mouseX = 0, mouseY = 0;
        let isPlaying = false;
        let hue = 0;

        let audioCtx, osc, gainNode, analyser;
        const waveforms = ["sine", "triangle", "sawtooth", "square"];
        let currentWave = 0;

        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            osc = audioCtx.createOscillator();
            osc.type = waveforms[currentWave];

            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0;

            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;

            osc.connect(gainNode);
            gainNode.connect(analyser);
            analyser.connect(audioCtx.destination);

            osc.start();
            isPlaying = true;
            overlay.style.opacity = 0;
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
        }
        window.addEventListener("resize", resize);
        resize();

        window.addEventListener("mousemove", (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;

            if (isPlaying) {
                const freqPercentage = mouseX / width;
                const freq = 100 + freqPercentage * 1000;
                osc.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.05);

                const volPercentage = 1 - mouseY / height;
                gainNode.gain.setTargetAtTime(volPercentage * 0.5, audioCtx.currentTime, 0.05);
            }
        });

        window.addEventListener("mousedown", () => {
            if (!isPlaying) {
                initAudio();
            } else {
                currentWave = (currentWave + 1) % waveforms.length;
                osc.type = waveforms[currentWave];

                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, width, height);
            }
        });

        function draw() {
            requestAnimationFrame(draw);

            ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
            ctx.fillRect(0, 0, width, height);

            if (!isPlaying) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);

            ctx.lineWidth = 2;
            hue += 1;
            ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;

            const slices = 12;
            const sliceAngle = (Math.PI * 2) / slices;

            for (let i = 0; i < slices; i++) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(i * sliceAngle);
                ctx.rotate(hue * 0.01);

                ctx.beginPath();

                for (let j = 0; j < bufferLength; j++) {
                    const v = dataArray[j] / 128.0;
                    const y = v * (height / 4) + 50;
                    const x = j * 2;

                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }

                ctx.stroke();
                ctx.restore();
            }

            const radius = gainNode.gain.value * 100 + 10;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${hue + 180}, 100%, 50%)`;
            ctx.fill();
        }

        draw();
    </script>

</body>
</html>
